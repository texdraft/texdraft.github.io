<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"> 
    <meta name="viewport" content="width=device-width, maximum-scale=1">
    <link rel="stylesheet" type="text/css" href="../style.css">
    <link rel="stylesheet" type="text/css" href="../fonts/fonts.css">
    <title>Lisp Compiler</title>
  </head>
  <body class="normal">
    <div class="article-title">
      <h1>The First Lisp Compiler</h1>
      <h2>By Asher Olsen</h2>
    </div>
    <article>
      <div class="contents">
        <h2>Contents</h2>
        <ol>
          <li>
            <a href="#introduction">Introduction</a>
          </li>
          <li>
            <a href="#the-source">The source</a>
          </li>
          <li>
            <a href="#compiler-fundamentals">Fundamentals of the <abbr title="Hart&ndash;Levin compiler">HLC</abbr></a>
          </li>
          <li>
            <a href="#using-the-compiler">Using the <abbr title="Hart&ndash;Levin compiler">HLC</abbr></a>
          </li>
          <li>
            <a href="#pass-one">Pass one</a>
            <ol>
              <li>
                <a href="#tail-call">Tail call elimination</a>
              </li>
              <li>
                <a href="#pass-one-special-common">Special and common variables</a>
              </li>
              <li>
                <a href="#pass-one-others">Other transformations</a>
              </li>
            </ol>
          </li>
          <li>
            <a href="#pass-two">Pass two</a>
            <ol>
              <li>
                <a href="#the-listing">The listing</a>
              </li>
              <li>
                <a href="#locating-values">Locating values</a>
              </li>
              <li>
                <a href="#function-prologues-and-epilogues-and-linkage">Function prologues and epilogues and linkage</a>
              </li>
              <li>
                <a href="#compiling-an-expression">Compiling an expression</a>
                <ol>
                  <li>
                    <a href="#compiling-atoms-and-variables">Compiling atoms and variables</a>
                  </li>
                  <li>
                    <a href="#compiling-assignments">Compiling assignments</a>
                  </li>
                  <li>
                    <a href="#compiling-function-calls">Compiling function calls</a>
                  </li>
                  <li>
                    <a href="#compiling-prog-forms">Compiling prog forms</a>
                  </li>
                  <li>
                    <a href="#compiling-conditionals">Compiling conditionals</a>
                  </li>
                </ol>
              </li>
            </ol>
          </li>
        </ol>
      </div>
      <section class="normal" id="introduction">
        <h2><a href="#introduction" class="section-title">Introduction</a></h2>
        <p>
This page examines the earliest surviving Lisp compiler, written by Timothy Hart and Michael Levin around 1961.
To avoid repetition of phrases like &ldquo;the compiler&rdquo;, we will use the abbreviation
&ldquo;<abbr title="Hart&ndash;Levin compiler">HLC</abbr>&rdquo; (for &ldquo;Hart&ndash;Levin Compiler&rdquo;)
to refer to it. The <abbr title="Hart&ndash;Levin compiler">HLC</abbr> was introduced in
<a href="ftp://publications.ai.mit.edu/ai-publications/pdf/AIM-039.pdf" class="external-link">M.I.T. <abbr title="A.I. Memo">AIM</abbr>-039</a>
and documented more fully in the <cite><a href="http://www.softwarepreservation.org/projects/LISP/book/LISP%201.5%20Programmers%20Manual.pdf" class="external-link">LISP 1.5 Programmer's Manual</a></cite>
by McCarthy et al.
        </p>
        <p>
For information about the timeline of Lisp compilers, I refer you to the ques&shy;tion
&ldquo;<a href="https://retrocomputing.stackexchange.com/a/12279" class="external-link">What was the first Lisp compiler</a>&rdquo;
on the
<a href="https://retrocomputing.stackexchange.com/" class="external-link">Retrocomputing Stack&shy;Exchange site</a>;
the answer there gives an excellent overview. We will be focusing on implementation details.
It should be mentioned, however, that al&shy;though the title of this page is &ldquo;The <em>First</em> Lisp Compiler&rdquo;,
the <abbr title="Hart&ndash;Levin compiler">HLC</abbr> is really the <em>second</em> Lisp compiler. A more correct title would be
&ldquo;The First Good Lisp Com&shy;piler&rdquo; or &ldquo;The First Lisp Compiler Whose Source Code is Available&rdquo;.
        </p>
        <p>
In order to understand the <abbr title="Hart&ndash;Levin compiler">HLC</abbr>, a decent amount of prequisite knowledge is required, about the
machine LISP&nbsp;1.5 ran on and about LISP&nbsp;1.5 itself. If you aren't already familiar, I recommend reading
the <cite><a href="http://www.softwarepreservation.org/projects/LISP/book/LISP%201.5%20Programmers%20Manual.pdf" class="external-link">LISP&nbsp;1.5 Programmer's Manual</a></cite>
linked above and checking out Jack Harper's <a href="https://web.archive.org/web/20200630102054/http://www.frobenius.com/7090.htm" class="external-link">site on the IBM 7090</a>.
You might also be interested in <a href="https://github.com/munificent/craftinginterpreters/issues/906" class="external-link">a GitHub issue I wrote a little while ago</a>.
        </p>
      </section>
      <section class="normal" id="the-source">
        <h2><a href="#the-source" class="section-title">The source</a></h2>
        <p>
The source code of the <abbr title="Hart&ndash;Levin compiler">HLC</abbr> comes from
<a href="https://github.com/rcornwell/ctss" class="external-link">an archive of CTSS source code</a>, namely
<a href="https://github.com/rcornwell/ctss/blob/master/extra/lisp/lispset.job#L278" class="external-link">lines 278&ndash;592 of file
<span class="path">ctss/lispset.job</span></a>.
Reading the code in its original form is quite difficult, since there is virtually
no indentation or meaningful spacing. Occasionally atoms will start on one line/card and end on the next!
And of course all-uppercase text is not known for being especially readable. Therefore I have prepared a
<a href="listing.html" class="internal-link">formatted and cross-referenced version of the code</a> for easy viewing.
        </p>
        <p>
Even though the code looks pretty, I still find it hard to follow. All destruc&shy;turing is done with
compositions of <span class="function">car</span> and <span class="function">cdr</span>. (I'm not criticizing
the authors here, since it's not like LISP&nbsp;1.5 gave them anything better to work with. But it feels like
a step down when compared to Common Lisp, where we have <a href="http://www.lispworks.com/documentation/lw50/CLHS/Body/03_d.htm" class="external-link">fancy lambda lists</a>
and <a href="http://www.lispworks.com/documentation/lw50/CLHS/Body/m_destru.htm#destructuring-bind" class="external-link"><span class="operator">destructuring-bind</span></a>.)
An additional obscurity lies in the choices of function and variable names. For example, the name
<a href="listing.html#definition-pi2" class="internal-link"><span class="function">pi2</span></a>
provides no clue as to its purpose (which is to construct a <span class="operator">setq</span> form). I think this
is an assembly language convention.
        </p>
        <p>
To run the code, you could try <a href="http://www.softwarepreservation.org/projects/LISP/lisp15_family#LISP_I_and_LISP_1.5_for_IBM_704,_709,_7090_" class="external-link">simulating the LISP&nbsp;1.5 system</a>,
or you can use <a href="https://gist.github.com/texdraft/5570f5e7a9b71f245d8eb1f442c9c47c" class="external-link">my translation to Common Lisp</a>.
Note: This translation does the bare mini&shy;mum to get it running. I make no attempt to use any high-level Common Lisp constructs;
the aim was to leave the code as unchanged as possible except to add indentation. To compile the compiler, uncomment the lines at the bottom.
        </p>
        <p>
The source code of an earlier version of the <abbr title="Hart&ndash;Levin compiler">HLC</abbr> also exists, in a document titled
&ldquo;<a href="http://www.softwarepreservation.org/projects/LISP/lisp1.5/LISP_LIBRARY_NOVEMBER_1963.pdf" class="external-link">LISP LIBRARY NOVEMBER 1963</a>&rdquo;.
        </p>
      </section>
      <section class="normal" id="compiler-fundamentals">
        <h2><a href="#compiler-fundamentals" class="section-title">Fundamentals of the <abbr title="Hart&ndash;Levin compiler">HLC</abbr></a></h2>
        <p>
Here is how the implementers describe the <abbr title="Hart&ndash;Levin compiler">HLC</abbr> (from <a href="ftp://publications.ai.mit.edu/ai-publications/pdf/AIM-039.pdf" class="external-link"><abbr title="A.I. Memo">AIM</abbr>-039</a>):
        </p>
        <blockquote>
          <p>
… It is written entirely in LISP and is the first compiler that has ever
compiled itself by being executed interpretively.
          </p>
        </blockquote>
        <p>
Another early effort that might also claim this honor is Donald Knuth's
<a href="https://doi.org/10.1145/368481.368507" class="external-link">RUNCIBLE</a>;
Knuth described an algorithm to translate RUNCIBLE expres&shy;sions into assembly language,
and <a href="https://archive.computerhistory.org/resources/text/Knuth_Don_X4100/PDF_index/k-3-pdf/k-3-c1034-DRUNCIBLE-listing.pdf" class="external-link">implemented it in RUNCIBLE itself</a>.
        </p>
        <blockquote>
          <p>
The purpose of the LISP compiler is to replace S-expression def&shy;initions of functions with
efficient machine language subroutines. A subroutine can be expected to run about 40 times
as fast as the interpreter can execute the same function from its S-expres&shy;sion definition.
Subroutines typically take 70&ndash;80 per cent of the storage required by their
corresponding S-expressions.
          </p>
        </blockquote>
        <p>
Such a drastic speed-up was possible because the LISP 1.5 interpreter was not especially efficient.
        </p>
        <p>
The <abbr title="Hart&ndash;Levin compiler">HLC</abbr> was notable for several aspects:
        </p>
        <ul>
          <li>
            <p>
It was the first compiler to attempt to transform a tail call
into a transfer instruction that doesn't incur the function call overhead.
However, it recognized only a certain case of tail calls.
            </p>
          </li>
          <li>
            <p>
It created a behavioral distinction between compiled and interpreted Lisp code
that would be the norm until Common Lisp in 1984.
            </p>
          </li>
          <li>
            <p>
It did no control-flow or data-flow optimizations other than the tail call elimination. In particular, it
did not attempt to avoid conversions to and from boxed representations of numeric values;
all arithmetic was still done by function calls. No functions were open-coded.
            </p>
          </li>
          <li id="two-passes">
            <p>
It operated in two clearly separated passes.
            </p>
          </li>
        </ul>
      </section>
      <section class="normal" id="using-the-compiler">
        <h2><a href="#using-the-compiler" class="section-title">Using the <abbr title="Hart&ndash;Levin compiler">HLC</abbr></a></h2>
        <p>
The main entry point to the <abbr title="Hart&ndash;Levin compiler">HLC</abbr> is the
<a href="listing.html#definition-compile" class="internal-link"><span class="function">compile</span></a>
function,
which takes a list of function names and compiles their definitions. In LISP&nbsp;1.5, function definitions
were stored on the property list of the function's name, under one of the indica&shy;tors
<span class="indicator">EXPR</span> (for interpreted definitions), <span class="indicator">FEXPR</span> (interpreted and
accepting a variable number of unevaluated arguments), <span class="indicator">SUBR</span> (implemented in machine code),
or <span class="indicator">FSUBR</span> (implemented in machine code and accepting a variable number of
unevaluated arguments). The <abbr title="Hart&ndash;Levin compiler">HLC</abbr> replaces an <span class="indicator">EXPR</span> or <span class="indicator">FEXPR</span> property with
a <span class="indicator">SUBR</span> or <span class="indicator">FSUBR</span> property.
        </p>
        <p>
Code acceptable to the interpreter is not necessarily acceptable to the <abbr title="Hart&ndash;Levin compiler">HLC</abbr>. For
managing the values of variables, the interpreter used a simple association list; it had
no concept of scope. On the other hand, compiled code avoids manip&shy;ulation of an
environment by storing values on the push-down list (AKA the stack). Thus
the <abbr title="Hart&ndash;Levin compiler">HLC</abbr> effectively supported lexical scoping. The <abbr title="Hart&ndash;Levin compiler">HLC</abbr> still allowed variables
with indefinite scope, but they must be explicitly declared as such by using the
<a href="listing.html#definition-special" class="internal-link"><span class="function">special</span></a>
function. If a special variable was also meant to be shared between
compiled and interpreted functions, it must be declared in a different way, with the
<a href="listing.html#definition-common" class="internal-link"><span class="function">common</span></a>
function. (Declarations can be reversed by the
<a href="listing.html#definition-unspecial" class="internal-link"><span class="function">unspecial</span></a>
and
<a href="listing.html#definition-uncommon" class="internal-link"><span class="function">uncommon</span></a>
functions.) We will see later how the special/common variable mechanism worked internally.
        </p>
        <p>
The <abbr title="Hart&ndash;Levin compiler">HLC</abbr> generated code in the form of a symbolic listing and handed it to
<span class="function">lap</span>, the Lisp Assembly Program, which converted the listing into machine code
and “installed” it in the computer's memory. The <abbr title="Hart&ndash;Levin compiler">HLC</abbr> also printed out the listing.
        </p>
    </section>
      <section class="normal" id="pass-one">
        <h2><a href="#pass-one" class="section-title">Pass one</a></h2>
        <p>
Pass one of the <abbr title="Hart&ndash;Levin compiler">HLC</abbr> is encapsulated within the function
<a href="listing.html#definition-passone" class="internal-link"><span class="function">passone</span></a>.
The goal of the first pass is to transform a Lisp expression into another Lisp expression that is potentially easier for the
compiler to deal with. In some cases, the output of
<a href="listing.html#definition-passone" class="internal-link"><span class="function">passone</span></a>
is <em>not</em> a valid Lisp expression, but rather a kind of annotation for the second pass to act on.
        </p>
        <p>
The main &ldquo;worker&rdquo; in pass one is
<a href="listing.html#definition-paform" class="internal-link"><span class="function">paform</span></a>,
which is given any form that is to be evaluated. For instance, in a normal function call
<a href="listing.html#definition-paform" class="internal-link"><span class="function">paform</span></a>
is mapped over all the arguments. Caution must be exercised with operators that don't follow
ordi&shy;nary evaluation rules: It would be quite incorrect to hand
<a href="listing.html#definition-paform" class="internal-link"><span class="function">paform</span></a>
the subforms of a <span class="operator">cond</span> expression.
        </p>
        <section class="normal" id="tail-call">
          <h3><a href="#tail-call" class="section-title">Tail call elimination</a></h3>
          <p>
The first transformation applied converts a specific case of recursion into iteration, i.e., it performs (limited) tail call elimination.
This is done by the
<a href="listing.html#definition-progiter" class="internal-link"><span class="function">progiter</span></a>
subroutine. Suppose that we are defining a function named <span class="function">f</span>. Then
<a href="listing.html#definition-progiter" class="internal-link"><span class="function">progiter</span></a>
checks to see whether <span class="function">f</span>'s definition is of the form
          </p>
          <div class="listing">
            <table>
              <tbody>
                <tr>
                  <td>
                    (<span class="operator">cond</span>
                    <table>
                      <tbody>
                        <tr>
                          <td>
                            &hellip;
                          </td>
                        </tr>
                        <tr>
                          <td>
                            (<table>
                              <tbody>
                                <tr>
                                  <td>(<span class="function">predicate</span>)</td>
                                </tr>
                                <tr>
                                  <td>
                                    (<span class="function">f</span> &hellip;))
                                  </td>
                                </tr>
                              </tbody>
                            </table>
                          </td>
                        </tr>
                        <tr>
                          <td>&hellip;).</td>
                        </tr>
                      </tbody>
                    </table>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <p>
In other words, it looks for a <span class="operator">cond</span> expression that
has at least one clause whose consequent expression is a recursive call to the function
being defined. If such an expression is found, the
<a href="listing.html#definition-progiter1" class="internal-link"><span class="function">progiter1</span></a>
function is called upon to do the actual transformation.
          </p>
          <p>
Four arguments are given to
<a href="listing.html#definition-progiter1" class="internal-link"><span class="function">progiter1</span></a>:
          </p>
          <ol>
            <li>
              <var>g1</var>, a fresh, uninterned symbol created by <span class="function">gensym</span>.
This will be used as a <span class="operator">prog</span> tag.
            </li>
            <li>
              <var>g2</var>, ditto.
            </li>
            <li>
              <var>vs</var>, the parameters of the function being defined.
            </li>
            <li>
              <var>gs</var>, a list of fresh symbols, one for each parameter.
            </li>
          </ol>
          <p>
The goal is to create a <span class="operator">prog</span> form, replacing recursive calls
with <span class="operator">go</span> statements and replacing other <span class="operator">cond</span>
clauses with <span class="operator">return</span> statements. Here is what we might get when
<a href="listing.html#definition-member" class="internal-link"><span class="function">member</span></a>
is run through
<a href="listing.html#definition-progiter" class="internal-link"><span class="function">progiter</span></a>
(the generated symbols use Common Lisp syntax):
          </p>
          <div class="listing">
            <table>
              <tbody>
                <tr>
                  <td>
                    (&lambda; (<var>u</var> <var>v</var>)
                  </td>
                </tr>
                <tr>
                  <td>
                    <table class="indent prog">
                      <tbody>
                        <tr>
                          <td>(<span class="operator">prog</span>&nbsp;</td>
                          <td>(<var>#:g480</var> <var>#:g481</var>)</td>
                        </tr>
                        <tr>
                          <td class="prog-tag">#:g478</td>
                          <td>
                            (<span class="operator">cond</span>
                            <table>
                              <tbody>
                                <tr>
                                  <td>
                                    (<table>
                                      <tbody>
                                        <tr>
                                          <td>
                                            (<span class="function">null</span> <var>v</var>)
                                          </td>
                                        </tr>
                                        <tr>
                                          <td>
                                            (<span class="operator">return</span>
                                            <span class="constant">nil</span>))
                                          </td>
                                        </tr>
                                      </tbody>
                                    </table>
                                  </td>
                                </tr>
                                <tr>
                                  <td>
                                    (<table>
                                      <tbody>
                                        <tr>
                                          <td>
                                            (<span class="function">equal</span>
                                            (<span class="function">car</span> <var>v</var>) <var>u</var>)
                                          </td>
                                        </tr>
                                        <tr>
                                          <td>
                                            (<span class="operator">return</span>
                                            <var>t</var>))
                                          </td>
                                        </tr>
                                      </tbody>
                                    </table>
                                  </td>
                                </tr>
                                <tr>
                                  <td>
                                    (<table>
                                      <tbody>
                                        <tr>
                                          <td>
                                            <var>t</var>
                                          </td>
                                        </tr>
                                        <tr>
                                          <td>
                                            (<span class="operator">go</span>
                                            <span class="prog-tag">#:g482</span>)))
                                          </td>
                                        </tr>
                                      </tbody>
                                    </table>
                                  </td>
                                </tr>
                              </tbody>
                            </table>
                          </td>
                        </tr>
                        <tr>
                          <td class="prog-tag">#:g482</td>
                          <td>
                            (<span class="operator">setq</span> <var>#:g480</var> <var>u</var>)
                          </td>
                        </tr>
                        <tr>
                          <td></td>
                          <td>
                            (<span class="operator">setq</span> <var>#:g481</var>
                            (<span class="function">cdr</span> <var>v</var>))
                          </td>
                        </tr>
                        <tr>
                          <td></td>
                          <td>
                            (<span class="operator">go</span>
                            <span class="prog-tag">#:g479</span>)
                          </td>
                        </tr>
                        <tr>
                          <td class="prog-tag">#:g479</td>
                          <td>
                            (<span class="operator">setq</span> <var>u</var> <var>#:g480</var>)
                          </td>
                        </tr>
                        <tr>
                          <td></td>
                          <td>
                            (<span class="operator">setq</span> <var>v</var> <var>#:g481</var>)
                          </td>
                        </tr>
                        <tr>
                          <td></td>
                          <td>
                            (<span class="operator">go</span>
                            <span class="prog-tag">#:g478</span>))).
                          </td>
                        </tr>
                      </tbody>
                    </table>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <p>
I confess that I am unsure why the tag <span class="prog-tag">#:g479</span>
(and the <span class="operator">go</span> thereto) is necessary.
However, the extra variables for the parameters are essential to avoid problems with
indefinite scope. For example, let's say that we have a function <span class="function">g</span>
defined as follows.
          </p>
          <div class="listing">
            <table>
              <tbody>
                <tr>
                  <td>
                    (&lambda; (<var>x</var> <var>y</var>)
                  </td>
                </tr>
                <tr>
                  <td>
                    <table class="indent">
                      <tbody>
                        <tr>
                          <td>
                            (<span class="operator">cond</span>
                            <table>
                              <tbody>
                                <tr>
                                  <td>
                                    (<table>
                                      <tbody>
                                        <tr>
                                          <td>
                                            (<span class="function">eq</span>
                                            (<span class="function">car</span> <var>y</var>)
                                            <var>x</var>)
                                          </td>
                                        </tr>
                                        <tr>
                                          <td> 
                                            <span class="constant">nil</span>)
                                          </td>
                                        </tr>
                                      </tbody>
                                    </table>
                                  </td>
                                </tr>
                                <tr>
                                  <td>
                                    (<table>
                                      <tbody>
                                        <tr>
                                          <td>
                                            <var>t</var>
                                          </td>
                                        </tr>
                                        <tr>
                                          <td>
                                            (<span class="function">g</span>
                                            (<span class="function">h</span> <var>x</var>)
                                            (<span class="function">cdr</span> <var>y</var>)))))
                                          </td>
                                        </tr>
                                      </tbody>
                                    </table>
                                  </td>
                                </tr>
                              </tbody>
                            </table>
                          </td>
                        </tr>
                      </tbody>
                    </table>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <p>
If <var>y</var> is declared special, and <span class="function">h</span> modifies <var>y</var>,
then the obvious expansion that directly sets <var>x</var> and <var>y</var> would be incorrect, since
<var>y</var> would be changed before <code>(<span class="function">cdr</span>&nbsp;<var>y</var>)</code> is
evaluated. (In Common Lisp,
<a href="http://www.lispworks.com/documentation/lw50/CLHS/Body/m_psetq.htm#psetq" class="external-link"><span class="operator">psetq</span></a> or
<a href="http://www.lispworks.com/documentation/lw50/CLHS/Body/m_setf_.htm#psetf" class="external-link"><span class="operator">psetf</span></a>
could be used to achieve the same effect.)
          </p>
        </section>
        <section class="normal" id="pass-one-special-common">
          <h3><a href="#pass-one-special-common" class="section-title">Special and common variables</a></h3>
          <p>
To make the job of the second pass easier, pass one determines and marks all special and common variables.
Specifically, the following changes are made:
          </p>
          <ul>
            <li>
              <p>
A reference to a special variable <var>x</var> will be turned into
<code>(<span class="operator">special</span> <var>x</var>)</code>. Thus the form
<code>(<span class="operator">setq</span> <var>x</var> <var>y</var>)</code>, where
<var>x</var> and <var>y</var> have been declared special, becomes
<code>(<span class="operator">setq</span> (<span class="operator">special</span> <var>x</var>) (<span class="operator">special</span> <var>y</var>))</code>.
Note that this code is not valid LISP&nbsp;1.5; the compiler will deal with it &ldquo;specially&rdquo;.
              </p>
            </li>
            <li>
              <p>
A reference to a common variable <var>c</var> will be turned into the expression
<code>(<span class="function">eval</span> (<span class="operator">quote</span> c) <var>$alist</var>)</code>.
The effect is to invoke the interpreter to compute the value of <var>c</var>. Of course, this won't work with
<span class="operator">setq</span>, so&hellip;
              </p>
            </li>
            <li>
              <p>
A <span class="operator">setq</span> of a common variable <var>c</var> becomes a
call to <span class="function">setc</span>, with the variable's name quoted, as in
<code>(<span class="function">setc</span> (<span class="operator">quote</span> c) <var>whatever</var>)</code>.
This <span class="function">setc</span> function is obscure; it is not defined
in the source code of the M.I.T. interpreter.
It is not to be confused with the <span class="function">cset</span> function, which is well documented.
There is a definition of <span class="function">setc</span> in
<a href="http://www.softwarepreservation.org/projects/LISP/stanford/LISP_360_Reference_Manual-SCC024-1972_03.pdf#page=44" class="external-link">the reference manual for a LISP&nbsp;1.5 interpreter on the IBM 360</a>,
but it is not compatible with the <span class="function">setc</span> here.
              </p>
            </li>
            <li id="specbind-specrstr">
              <p>
Any form that creates a binding of special and/or common variables is radically altered
so that the second pass will generate code to save the current values before the form is
executed and to restore them after&shy;wards. Let's look at an example first.
Assume that <var>x</var> and <var>y</var> have been declared common, and that
<var>z</var> has been declared special.
              </p>
              <div class="listing">
                <table>
                  <tbody>
                    <tr>
                      <td>
                        (<span class="operator">lambda</span> (<var>x</var> <var>y</var> <var>z</var>)
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <table class="indent">
                          <tbody>
                            <tr>
                              <td>
                                (<span class="operator">cond</span>
                                <table>
                                  <tbody>
                                    <tr>
                                      <td>
                                        (<table>
                                          <tbody>
                                            <tr>
                                              <td>
                                                (<span class="function">eq</span> <var>x</var> <var>y</var>)
                                              </td>
                                            </tr>
                                            <tr>
                                              <td>
                                                (<span class="operator">prog</span>
                                                <table>
                                                  <tbody>
                                                    <tr>
                                                      <td>
                                                        (<var>z</var>)
                                                      </td>
                                                    </tr>
                                                    <tr>
                                                      <td>
                                                        (<span class="operator">setq</span> <var>z</var> <var>x</var>)
                                                      </td>
                                                    </tr>
                                                    <tr>
                                                      <td>
                                                        (<span class="operator">return</span>
                                                        <var>t</var>)))
                                                      </td>
                                                    </tr>
                                                  </tbody>
                                                </table>
                                              </td>
                                            </tr>
                                          </tbody>
                                        </table>
                                      </td>
                                    </tr>
                                    <tr>
                                      <td>
                                        (<table>
                                          <tbody>
                                            <tr>
                                              <td>
                                                <var>t</var>
                                              </td>
                                            </tr>
                                            <tr>
                                              <td>
                                                <span class="constant">nil</span>)))
                                              </td>
                                            </tr>
                                          </tbody>
                                        </table>
                                      </td>
                                    </tr>
                                  </tbody>
                                </table>
                              </td>
                            </tr>
                          </tbody>
                        </table>
                      </td>
                    </tr>
                  </tbody>
                </table>
              </div>
              <p>
Here there are two forms that bind&mdash;the overall
<span class="operator">lambda</span> expression (though arguably not a &ldquo;form&rdquo; in this context)
and the <span class="operator">prog</span>. Pass one, via
<a href="listing.html#definition-pa4" class="internal-link"><span class="function">pa4</span></a>,
produces
              </p>
              <div class="listing">
                <table>
                  <tbody>
                    <tr>
                      <td>
                        (<span class="operator">&lambda;</span> (<var>x</var> <var>y</var> <var>z</var>)
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <table class="indent prog">
                          <tbody>
                            <tr>
                              <td>
                                (<span class="operator">prog</span>&nbsp;
                              </td>
                              <td>
                                (<var>#:g479</var>)
                              </td>
                            </tr>
                            <tr>
                              <td></td>
                              <td>
                                (<span class="function">combind</span>
                                (<span class="operator">quote</span> (x y))
                                (<span class="function">list</span> <var>x</var> <var>y</var>))
                              </td>
                            </tr>
                            <tr>
                              <td></td>
                              <td>
                                (<span class="function">specbind</span>
                                (<span class="operator">quote</span> (z)))
                              </td>
                            </tr>
                            <tr>
                              <td></td>
                              <td>
                                (<span class="operator">setq</span> <var>#:g479</var>
                                <table>
                                  <tbody>
                                    <tr>
                                      <td>
                                        (<span class="operator">cond</span>
                                        <table>
                                          <tbody>
                                            <tr>
                                              <td>
                                                (<table>
                                                  <tbody>
                                                    <tr>
                                                      <td>
                                                        (<span class="function">eq</span>
                                                        <table>
                                                          <tbody>
                                                            <tr>
                                                              <td>
                                                                (<span class="function">eval</span>
                                                                (<span class="operator">quote</span> x)
                                                                <var>$alist</var>)
                                                              </td>
                                                            </tr>
                                                            <tr>
                                                              <td>
                                                               (<span class="function">eval</span>
                                                               (<span class="operator">quote</span> y)
                                                               <var>$alist</var>))
                                                              </td>
                                                            </tr>
                                                          </tbody>
                                                        </table>
                                                      </td>
                                                    </tr>
                                                    <tr>
                                                      <td>
                                                        <table class="prog">
                                                          <tbody>
                                                            <tr>
                                                              <td>
                                                                (<span class="operator">prog</span>&nbsp;
                                                              </td>
                                                              <td>
                                                                (<var>#:g480</var> <var>z</var>)
                                                              </td>
                                                            </tr>
                                                            <tr>
                                                              <td></td>
                                                              <td>
                                                                (<span class="function">specbind</span>
                                                                (<span class="operator">quote</span> (z)))
                                                              </td>
                                                            </tr>
                                                            <tr>
                                                              <td></td>
                                                              <td>
                                                                (<span class="operator">setq</span> <var>#:g480</var>
                                                                <table class="prog">
                                                                  <tbody>
                                                                    <tr>
                                                                      <td>
                                                                        (<span class="operator">prog</span>&nbsp;
                                                                      </td>
                                                                      <td>
                                                                        (&thinsp;)
                                                                      </td>
                                                                    </tr>
                                                                    <tr>
                                                                      <td></td>
                                                                      <td>
                                                                        (<span class="operator">setq</span>
                                                                        (<span class="operator">special</span> <var>z</var>)
                                                                        (<span class="function">eval</span>
                                                                        (<span class="operator">quote</span> x)
                                                                        <var>$alist</var>))
                                                                      </td>
                                                                    </tr>
                                                                    <tr>
                                                                      <td></td>
                                                                      <td>
                                                                        (<span class="operator">return</span>
                                                                        (<span class="operator">quote</span> *t*))
                                                                      </td>
                                                                    </tr>
                                                                    <tr>
                                                                      <td></td>
                                                                      <td>
                                                                        (<span class="operator">return</span>
                                                                        (<span class="operator">quote</span> nil))))
                                                                      </td>
                                                                    </tr>
                                                                  </tbody>
                                                                </table>
                                                              </td>
                                                            </tr>
                                                            <tr>
                                                              <td></td>
                                                              <td>
                                                                (<span class="function">specrstr</span>
                                                                (<span class="operator">quote</span> (z)))
                                                              </td>
                                                            </tr>
                                                            <tr>
                                                              <td></td>
                                                              <td>
                                                                (<span class="operator">return</span> <var>#:g480</var>)))
                                                              </td>
                                                            </tr>
                                                          </tbody>
                                                        </table>
                                                      </td>
                                                    </tr>
                                                  </tbody>
                                                </table>
                                              </td>
                                            </tr>
                                            <tr>
                                              <td>
                                                (<table>
                                                  <tbody>
                                                    <tr>
                                                      <td>
                                                        (<span class="operator">quote</span> *t*)
                                                      </td>
                                                    </tr>
                                                    <tr>
                                                      <td>
                                                        (<span class="operator">quote</span> nil))))
                                                      </td>
                                                    </tr>
                                                  </tbody>
                                                </table>
                                              </td>
                                            </tr>
                                          </tbody>
                                        </table>
                                      </td>
                                    </tr>
                                  </tbody>
                                </table>
                              </td>
                            </tr>
                            <tr>
                              <td></td>
                              <td>
                                (<span class="function">specrstr</span>
                                (<span class="operator">quote</span> (z)))
                              </td>
                            </tr>
                            <tr>
                              <td></td>
                              <td>
                                (<span class="function">comrstr</span>
                                (<span class="operator">quote</span> 2))
                              </td>
                            </tr>
                            <tr>
                              <td></td>
                              <td>
                                (<span class="operator">return</span> <var>#:g479</var>))).
                              </td>
                            </tr>
                          </tbody>
                        </table>
                      </td>
                    </tr>
                  </tbody>
                </table>
              </div>
              <p>
(Note that this code showcases some pass one transformations that we have not encountered yet; see
<a href="#pass-one-others" class="internal-link">below</a>.
Also, generated symbols are ex&shy;pressed in Common Lisp syntax.)
              </p>
            </li>
              <p>
The functions <span class="function">specbind</span>, <span class="function">specrstr</span>,
<span class="function">combind</span>, and <span class="function">comrstr</span> are machine-coded
routines that handle binding special and common variables. No code for them exists in the M.I.T.
interpreter source code available online, unfor&shy;tunately. However, corresponding routines can
be found in other imple&shy;mentations, namely
<a href="http://www.softwarepreservation.org/projects/LISP/other_lisp15#Stanford_Lisp_360_" class="external-link">an interpreter on the IBM 360</a>
and the
<a href="http://www.softwarepreservation.org/projects/LISP/other_lisp15#LISP_1.5_for_AN/FSQ-32/V_" class="external-link">(compiler-only) Lisp on the AN/FSQ-32</a>.
              </p>
              <p>
More specifically, <span class="function">specbind</span> takes a list of symbols whose current special
bindings should be saved, and <span class="function">specrstr</span> takes a list of symbols whose previous
special binding should be restored. The <span class="function">combind</span> function ap&shy;pears to be similar,
although it takes a second argument, which is a list of values to which the common variables should be bound.
Finally, the <span class="function">comrstr</span> function takes the number of common variables bound by
<span class="function">combind</span> and restores their previous binding.
              </p>
            </li>
          </ul>
        </section>
        <section class="normal" id="pass-one-others">
          <h3><a href="#pass-one-others" class="section-title">Other transformations</a></h3>
          <p>
Here is the rest of what
<a href="listing.html#definition-paform" class="internal-link"><span class="function">paform</span></a>
does.
          </p>
          <ul>
            <li>
Self-evaluating forms (numbers, <span class="constant">nil</span>, and <span class="constant">*t*</span>) are quoted.
            </li>
            <li>
The variables <var>t</var> and <var>f</var> are changed to their <span class="indicator">APVAL</span>s
<span class="constant">*t*</span> and <span class="constant">nil</span> (quoted).
            </li>
            <li>
A call to <span class="function">not</span> changes into a call to <span class="function">null</span>.
            </li>
            <li>
A call to <span class="function">set</span> changes into a call to <span class="function">setc</span>.
            </li>
            <li>
A <span class="operator">csetq</span> form is changed into a <span class="function">cset</span> form, with
the argument quoted.
            </li>
            <li>
The <span class="indicator">FSUBR</span>s <span class="operator">select</span> and <span class="operator">conc</span>
are &ldquo;expanded&rdquo;&mdash;the former into a <span class="operator">cond</span>, the latter into a series of
<span class="function">append</span> calls.
            </li>
            <li>
The subforms of <span class="function">list</span>, <span class="operator">cond</span>, and
<span class="operator">setq</span> forms are
<a href="listing.html#definition-paform" class="internal-link"><span class="function">paform</span></a>'d
as necessary.
            </li>
            <li>
A <span class="operator">prog</span> form is <a href="#pass-one-special-common" class="internal-link">treated for special/common binding</a> and
has its non-atomic subforms
<a href="listing.html#definition-paform" class="internal-link"><span class="function">paform</span></a>'d. The expression
<code>(<span class="operator">return</span> (<span class="operator">quote</span> nil))</code> is added at the end, so that every
<span class="operator">prog</span> has an explicit final return.
            </li>
            <li>
Calls on <span class="operator">and</span> and <span class="operator">or</span> are left alone, except that
<a href="listing.html#definition-paform" class="internal-link"><span class="function">paform</span></a> is
applied to their subforms.
            </li>
            <li>
Other <span class="indicator">FSUBR</span>s, and all <span class="indicator">FEXPR</span>s, are expanded to reflect
the actual calling convention, where the underlying function is passed a list of the arguments and the current
environment.
            </li>
            <li>
&ldquo;Funarg&rdquo; expressions using <span class="operator">function</span> are converted into a call to a
myst&shy;erious <span class="function">func</span> function/operator. This does not appear to be docu&shy;mented anywhere,
in any Lisp implementation, and is not defined in the M.I.T. interpreter. It is passed the name of a function and the
current environ&shy;ment; if <span class="operator">function</span> is used with a &lambda; expression, the expression is
compiled and a name is generated for it.
            </li>
          </ul>
        </section>
      </section>
      <section class="normal" id="pass-two">
        <h2><a href="#pass-two" class="section-title">Pass two</a></h2>
        <p>
In the second pass, the Lisp code for a function, as processed by the first pass, is translated into assembly
instructions to be executed by the IBM 704/709/7090/7094 (henceforth referred to as simply &ldquo;the 7090&rdquo;). As
Bernard S.&nbsp;Greenberg says, in &ldquo;<a href="https://www.multicians.org/lcp.html#CHII" class="external-link">The Multics MACLISP Compiler</a>&rdquo;,
        </p>
        <blockquote>
          <p>
            The contract of a lisp compiler is to produce a machine-language program which, when executed, will have the
            same effect on the lisp environment, and return the same value, as having applied <span class="function">eval</span> to the forms it was
            given to compile.
          </p>
        </blockquote>
        <p>
While the first pass is a grab-bag of assorted, special-purpose functions, the second pass is a bit more structured.
Before we look at the translations of Lisp constructs, we need to be familiar with some variables and functions used
throughout pass two.
        </p>
        <section class="normal" id="the-listing">
          <h3><a href="#the-listing" class="section-title">The listing</a></h3>
          <p>
The generated code is held in the <var>listing</var> variable, which is a list of <abbr title="Lisp Assembly Program">LAP</abbr>
instructions. New instructions are added by passing a list to
<a href="listing.html#definition-attach" class="internal-link"><span class="function">attach</span></a>. Note that
<a href="listing.html#definition-attach" class="internal-link"><span class="function">attach</span></a> puts its argument at the
<em>front</em> of <var>listing</var>; after compilation has concluded, <var>listing</var> is reversed.
          </p>
        </section>
        <section class="normal" id="locating-values">
          <h3><a href="#locating-values" class="section-title">Locating values</a></h3>
          <p>
Local variables (parameters and <span class="operator">prog</span> variables) and compiler-generated temporaries are
stored on the Lisp system's push-down list or PDL. (Nowadays we would call it &ldquo;the stack&rdquo;.) In order to load
the value of such an entity, the compiler must know its position on the <abbr title="Push-down list">PDL</abbr>.
This is accomplished using a variable called <code><var>stomap</var></code> (&ldquo;storage map&rdquo;), and a
<abbr title="Lisp Assembly Program">LAP</abbr> symbol defined in each function's assembly output,
<code><var>*N</var></code>.
          </p>
          <p>
<span id="ir1-highest-pdl">In compiled code, <abbr title="Index register 1" class="register">IR1</abbr> always holds the address of the highest
<abbr title="Push-down list">PDL</abbr> cell used by this function.</span> The instruction for loading a variable's value into
<abbr title="Accumulator register" class="register">AC</abbr> normally looks like
(in <abbr title="Lisp Assembly Program">LAP</abbr> format)
            <table class="assembly">
              <tbody>
                <tr>
                  <td>
                    (<abbr title="Clear and add" class="assembly-instruction">CLA</abbr>
                  </td>
                  <td>
                    (<span class="constant">1</span> <var>*N</var>) <span class="constant">1</span>).
                  </td>
                </tr>
              </tbody>
            </table>
          </p>
          <p>
In <abbr title="Lisp Assembly Program">LAP</abbr>, the notation &ldquo;<code>(1&nbsp;<var>*N</var>)</code>&rdquo; means to add the constant
<code><span class="constant">1</span></code> to the value of the symbol <code><var>*N</var></code>.
For now it suffices to say that the value of <code><var>*N</var></code> is the negative of the total number of
<abbr title="Push-down list">PDL</abbr> cells needed for the function. Because of the way effective addresses are calculated on the 7090,
the above instruction ends up loading the <em>second</em> cell from the top of the <abbr title="Push-down list">PDL</abbr>, which is the
first cell used for local storage. (When we discuss function prologues, we will uncover the true meaning of <code><var>*N</var></code>.)
          </p>
          <p>
The <code><var>stomap</var></code> special variable maps variable names to lists of the form
<code>((<var>m</var>&nbsp;<var>*N</var>)&nbsp;<span class="constant">1</span>)</code>, where <var>m</var> is an integer. For example,
the function
          </p>
          <div class="listing">
            <table>
              <tbody>
                <tr>
                  <td>
                    (<span class="operator">&lambda;</span> (<var>a</var> <var>b</var> <var>c</var>)
                  </td>
                </tr>
                <tr>
                  <td>
                    <table class="indent">
                      <tbody>
                        <tr>
                          <td>
                            (<span class="function">cons</span> <var>a</var> (<span class="function">cons</span> <var>c</var> <var>b</var>)))
                          </td>
                        </tr>
                      </tbody>
                    </table>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <p>
Results in the <code><var>stomap</var></code>
          </p>
          <div class="listing">
            <table>
              <tbody>
                <tr>
                  <td>
                    (<table>
                      <tbody>
                        <tr>
                          <td>
                            (<var>#:g1964</var>&emsp;
                          </td>
                          <td>
                            .&emsp;
                          </td>
                          <td>
                            ((4 <var>*N</var>) 1))
                          </td>
                        </tr>
                        <tr>
                          <td>
                            (<var>c</var>
                          </td>
                          <td>
                            .
                          </td>
                          <td>
                            ((3 <var>*N</var>) 1))
                          </td>
                        </tr>
                        <tr>
                          <td>
                            (<var>b</var>
                          </td>
                          <td>
                            .
                          </td>
                          <td>
                            ((2 <var>*N</var>) 1))
                          </td>
                        </tr>
                        <tr>
                          <td>
                            (<var>a</var>
                          </td>
                          <td>
                            .
                          </td>
                          <td>
                            ((1 <var>*N</var>) 1))
                          </td>
                        </tr>
                        <tr>
                          <td>
                            (<var>nil</var>
                          </td>
                          <td>
                            .
                          </td>
                          <td>
                            ((0 <var>*N</var>) 1)))
                          </td>
                        </tr>
                      </tbody>
                    </table>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <p>
The <code><var>#:g1964</var></code> variable was created by the compiler to hold the result of the inner
<code><span class="function">cons</span></code>; the entry for <code><var>nil</var></code> is always present and never used.
          </p>
          <p>
When the compiler wishes to generate an instruction that refers to a local quantity, it calls
<a href="listing.html#definition-locate" class="internal-link"><span class="function">locate</span></a>, which searches in
<code><var>stomap</var></code> for a given name and returns the entry's <code><span class="function">cdr</span></code>.
(It also handles &ldquo;locating&rdquo; quoted values, but this is trivial thanks to
<abbr title="Lisp Assembly Program">LAP</abbr>.)
For example, to generate the <abbr title="Clear and add" class="assembly-instruction">CLA</abbr> above, we could call
          </p>
          <div class="listing">
            <table>
              <tbody>
                <tr>
                  <td>
                    (<a href="listing.html#definition-attach" class="internal-link"><span class="function">attach</span></a>
                    (<span class="function">list</span> (<span class="function">cons</span>
                    (<span class="operator">quote</span> cla)
                    (<a href="listing.html#definition-locate" class="internal-link"><span class="function">locate</span></a>
                    (<span class="operator">quote</span> a)))))
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <p>
Many functions bind <code><var>stomap</var></code>, so it can gain and then lose entries; the variable
<code><var>length</var></code> holds the greatest size of <code><var>stomap</var></code>.
          </p>
          <p>
Besides <a href="listing.html#definition-locate" class="internal-link"><span class="function">locate</span></a>, only
two functions access <code><var>stomap</var></code> directly:
          </p>
          <ul>
            <li>
              <p>
<a href="listing.html#definition-phase2" class="internal-link"><span class="function">phase2</span></a> initializes it to
<code>(<span class="operator">quote</span> ((nil (0 *n) 1)))</code> and also sets <code><var>length</var></code> to 0.
              </p>
            </li>
            <li>
              <p>
<a href="listing.html#definition-store" class="internal-link"><span class="function">store</span></a> is a routine
that adds an entry for a variable whose name is given as the first argument. It takes a second argument, which, when true,
causes a <abbr title="Store" class="assembly-instruction">STO</abbr> instruction to be emitted. This function takes care of
updating <code><var>length</var></code>.
              </p>
            </li>
          </ul>
          <p>
Finally, the utility routine <a href="listing.html#definition-lac" class="internal-link"><span class="function">lac</span></a>
should be mentioned. It has the simple task of generating a <abbr title="Clear and add" class="assembly-instruction">CLA</abbr>
instruction to load a variable of a given name into <abbr title="Accumulator register" class="register">AC</abbr>
(unless it is already in the simulated accumulator; see below).
          </p>
        </section>
        <section id="function-prologues-and-epilogues-and-linkage">
          <h3><a href="#function-prologues-and-epilogues-and-linkage" class="section-title">Function prologues and epilogues and linkage</a></h3>
          <p>
Every compiled function begins with the following two instructions:
          </p>
          <div>
            <table class="assembly">
              <tbody>
                <tr>
                  <td>(<abbr title="Transfer and set index" class="assembly-instruction">TSX</abbr>
                  </td>
                  <td><span class="function">*MOVE</span>
                  </td>
                  <td><span class="constant">1</span>
                  </td>
                  <td>&langle;number of arguments&rangle;)
                  </td>
                </tr>
                <tr>
                  <td>(<abbr title="Transfer on no index" class="assembly-instruction">TNX</abbr>
                  </td>
                  <td>(<span class="operator">E</span> &langle;name of this function&rangle;)
                  </td>
                  <td><span class="constant">1</span>
                  </td>
                  <td><var>*MN</var>)
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <p>
The effect is to set up the <abbr title="Push-down list">PDL</abbr>, so that it contains the function's arguments and
has room for any other local variables needed. Although simple enough in concept, the exact mechanism at play is rather
annoyingly complex.
          </p>
          <p>
First of all, the second instruction isn't really an instruction at all. It's more like an argument to the
<code id="move-routine"><span class="function">*MOVE</span></code> routine. The 7090 did not have a hardware stack, and passing arguments
by using additional &ldquo;instructions&rdquo; after a
<abbr title="Transfer and set index" class="assembly-instruction">TSX</abbr> was one way to avoid the limitation of
keeping everything in the two general-purpose registers. (This sort of thing is nearly unheard of today. If you don't
know how it would have been done on the 7090, I recommend reading
<a href="https://web.archive.org/web/20210424171134/http://www.frobenius.com/linkage.htm" class="external-link">Jack Harper's
page about subroutine linkage on the machine</a>; otherwise, the ensuing discussion will probably be confusing.)
          </p>
          <p>
To understand what <code><span class="function">*MOVE</span></code> does, we have to know a bit about the LISP&nbsp;1.5
system. The <abbr title="Push-down list">PDL</abbr> grows upwards, from a location stored in the decrement part of a
<abbr title="Transfer with index incremented" class="assembly-instruction">TXI</abbr> instruction labeled
<code><var>CPPI</var></code>. When a compiled function is called, at least four cells of the
<abbr title="Push-down list">PDL</abbr> are used.
          </p>
          <table>
            <tbody>
              <tr>
                <th>Cell</th>
                <th>Contents</th>
              </tr>
              <tr>
                <td>
                  <var>pdl</var>[0]:
                </td>
                <td>
                  <p>
A <abbr title="Transfer on index lower or equal to" class="assembly-instruction">TXL</abbr> instruction with
the return address in its decrement part, and the location of the present function in its address part.
                  </p>
                </td>
              </tr>
              <tr>
                <td>
                  <var>pdl</var>[1]:
                </td>
                <td>
The contents of <abbr title="Accumulator register" class="register">AC</abbr> (normally the first argument).
                </td>
              </tr>
              <tr>
                <td>
                  <var>pdl</var>[2]:
                </td>
                <td>
The contents of <abbr title="Multiplier/quotient" class="register">MQ</abbr> (normally the second argument).
                </td>
              </tr>
              <tr>
                <td>
                  <var>pdl</var>[3]:
                </td>
                <td>
First cell of local storage; possibly a third argument.
                </td>
              </tr>
              <tr>
                <td colspan="2" class="random-centered-table-row">
                  &vellip;
                </td>
              </tr>
              <tr>
                <td>
                  <var>pdl</var>[<var>*MN</var>]
                </td>
                <td>
The last cell of local storage.
                </td>
              </tr>
              <tr>
                <td>
                  <var>pdl</var>[<var>*MN</var>&nbsp;+&nbsp;1]
                </td>
                <td>
An <abbr title="Store location and trap" class="assembly-instruction">STR</abbr> instruction with <var>*MN</var>
in its decrement part.
                </td>
              </tr>
            </tbody>
          </table>
          <p>
As you can see, <var>*MN</var> is the total number of cells used for local storage, including the saved
<abbr title="Accumulator register" class="register">AC</abbr> and
<abbr title="Multiplier/quotient register" class="register">MQ</abbr>. Note that these registers are saved
no matter what, even if the function takes fewer than two arguments. The value of <var>*N</var> is the
negation of <var>*MN</var>.
          </p>
          <p>
The return address needs to be stored so that the function can return, naturally; the name is stored in order
to provide a backtrace in error messages. The
<abbr title="Store location and trap" class="assembly-instruction">STR</abbr> instruction is used when unwinding
the stack during such a backtrace or when something fails in an <code><span class="function">errorset</span></code>
form.
          </p>
          <p>
Calling <code><span class="function">*MOVE</span></code> creates a <abbr title="Push-down list">PDL</abbr>
entry in the above format. It also leaves a pointer to the top of the <abbr title="Push-down list">PDL</abbr>
in <abbr title="Index register 1" class="register">IR1</abbr>, as stated
<a href="#ir1-highest-pdl" class="internal-link">above</a>.
          </p>
          <p>
At the end of every compiled function is an instruction to load the return value into the accumulator,
followed by
          </p>
          <div>
            <table class="assembly">
              <tbody>
                <tr>
                  <td>
                    (<abbr title="Transfer with index incremented" class="assembly-instruction">TXI</abbr>
                    <span class="function">*RETURN</span>
                    <span class="constant">1</span>
                    <var>*MN</var>)
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <p id="return">
The <code><span class="function">*RETURN</span></code> routine restores the decrement part of
<var>CPPI</var> to its previous value, puts the return address in
<abbr title="Index register 4" class="register">IR4</abbr>, and then transfers to it.
          </p>
          <p>
But the complexities don't end there. The code generated for a function call contains an
<abbr title="Store location and trap" class="assembly-instruction">STR</abbr> instruction.
On the 7090, <abbr title="Store location and trap" class="assembly-instruction">STR</abbr> causes the
computer to transfer unconditionally to location 2, in which a
<abbr title="Trap transfer" class="assembly-instruction">TTR</abbr> instruction causes a further
transfer to the <code><span class="function">LINK</span></code> routine. This routine invokes
<code><span class="function">apply</span></code> if the called function is an
<span class="indicator">EXPR</span> or an <span class="indicator">FEXPR</span>. If the called
function in a <span class="indicator">SUBR</span> or an <span class="indicator">FSUBR</span>,
however, the routine modifies the <abbr title="Store location and trap" class="assembly-instruction">STR</abbr>
to be a <abbr title="Transfer and set index" class="assembly-instruction">TSX</abbr>
instruction that jumps directly to the function's address.
          </p>
        </section>
        <section class="normal" id="compiling-an-expression">
          <h3><a href="#compiling-an-expression" class="section-title">Compiling an expression</a></h3>
          <p>
We now turn to the code generated for the various expressions in Lisp. The most important function is
<a href="listing.html#definition-comval" class="internal-link"><span class="function">comval</span></a>, which,
as its name suggests, compiles an expression that produces a value. (It's the most important because all
Lisp expressions produce values.) The instructions generated by
<a href="listing.html#definition-comval" class="internal-link"><span class="function">comval</span></a> leave
the result of the expression in <abbr title="Accumulator register" class="register">AC</abbr>.
          </p>
          <p>
The <code><var>name</var></code> parameter of
<a href="listing.html#definition-comval" class="internal-link"><span class="function">comval</span></a>
holds a symbol that's supposed to be the name for the result. Except for the first call, when it's
<code><span class="constant">nil</span></code>, this symbol is always created by
<code><span class="function">gensym</span></code>. Other functions use <code><var>name</var></code> as well.
          </p>
          <p>
<span id="simulated-accumulator">During compilation, the second pass models the contents of
<abbr title="Accumulator register" class="register">AC</abbr> during execution, using the special variable
<code><var>ac</var></code></span>.
Once <a href="listing.html#definition-comval" class="internal-link"><span class="function">comval</span></a> has
finished, it sets <code><var>ac</var></code> to <code><var>name</var></code>, since
<a href="listing.html#definition-comval" class="internal-link"><span class="function">comval</span></a> puts
the value in <abbr title="Accumulator register" class="register">AC</abbr>.
          </p>
          <section class="normal" id="compiling-atoms-and-variables">
            <h4><a href="#compiling-atoms-and-variables" class="section-title">Compiling atoms and variables</a></h4>
            <p>
Atoms and variables take no effort. The result is a
<abbr title="Clear and add" class="assembly-instruction">CLA</abbr> instruction produced by
<a href="listing.html#definition-lac" class="internal-link"><span class="function">lac</span></a>,
because <abbr title="Lisp Assembly Program">LAP</abbr> takes care of the dirty work.
            </p>
          </section>
          <section class="normal" id="compiling-assignments">
            <h4><a href="#compiling-assignments" class="section-title">Compiling assignments</a></h4>
            <p>
The code generated for the expression
            </p>
            <div class="listing">
              <table>
                <tbody>
                  <tr>
                    <td>
                      (<span class="operator">setq</span> <var>x</var> &langle;expression&rangle;)
                    </td>
                  </tr>
                </tbody>
              </table>
            </div>
            <p>
is
            </p>
            <div>
              <table class="assembly">
                <tbody>
                  <tr>
                    <td>
                      code for &langle;expression&rangle;
                    </td>
                  </tr>
                  <tr>
                    <td>(<abbr title="Store" class="assembly-instruction">STO</abbr>
                      &langle;location of <var>x</var>&rangle;),
                    </td>
                  </tr>
                </tbody>
              </table>
            </div>
            <p>
where <code>&langle;location of <var>x</var>&rangle;</code> is the result of calling
<a href="listing.html#definition-locate" class="internal-link"><span class="function">locate</span></a>
on <code><var>x</var></code>.
            </p>
          </section>
          <section class="normal" id="compiling-function-calls">
            <h4><a href="#compiling-function-calls" class="section-title">Compiling function calls</a></h4>
            <p>
The instruction that calls a normal compiled or interpreted function <code><span class="function">f</span></code>, generated by
<a href="listing.html#definition-call" class="internal-link"><span class="function">call</span></a>, is
            </p>
            <div>
              <table class="assembly">
                <tbody>
                  <tr>
                    <td>
                      (<abbr title="Store location and trap" class="assembly-instruction">STR</abbr>
                    </td>
                    <td>
                      (<span class="operator">E</span> <span class="function">f</span>)
                    </td>
                    <td>
                      <span class="constant">7</span>
                    </td>
                    <td>
                      <var>n</var>),
                    </td>
                  </tr>
                </tbody>
              </table>
            </div>
            <p>
where <var>n</var> is the number of arguments. Before the <abbr title="Store location and trap" class="assembly-instruction">STR</abbr>,
the compiler needs to set up the arguments, if the function requires them. The evaluation of the arguments is handled by
<a href="listing.html#definition-comlis" class="internal-link"><span class="function">comlis</span></a>, which applies
<a href="listing.html#definition-comval" class="internal-link"><span class="function">comval</span></a> to the non-atomic
non-constant subexpressions in the call. Each such subexpression is replaced by a temporary name, which is put on the <var>stomap</var>.
Thus all arguments are symbols or constants, when
<a href="listing.html#definition-call" class="internal-link"><span class="function">call</span></a> gets hold of them.
            </p>
            <p>
The first argument is passed in <abbr title="Accumulator register" class="register">AC</abbr>;
<a href="listing.html#definition-call" class="internal-link"><span class="function">call</span></a> checks
<code><var>ac</var></code> to avoid an unnecessary <abbr title="Clear and add" class="assembly-instruction">CLA</abbr>
instruction. The second argument is passed in <abbr title="Multiplier/quotient register" class="register">MQ</abbr>.
            </p>
            <p>
All other arguments are stored in locations <var>$ALIST</var>&nbsp;+&nbsp;3, <var>$ALIST</var>&nbsp;+&nbsp;4, etc.
The process for each argument <var>a</var> at position <var>i</var> in the argument list has three cases:
            </p>
            <ol>
              <li>
                <p>
If <var>a</var> is <code><span class="constant">nil</span></code>, the output is
                </p>
                <div>
                  <table class="assembly">
                    <tbody>
                      <tr>
                        <td>
                          (<abbr title="Store zero" class="assembly-instruction">STZ</abbr>
                        </td>
                        <td>
                          (<var>$ALIST</var> <var>i</var>)).
                        </td>
                      </tr>
                    </tbody>
                  </table>
                </div>
              </li>
              <li>
                <p>
If <var>a</var> is in the accumulator, the output is
                </p>
                <div>
                  <table class="assembly">
                    <tbody>
                      <tr>
                        <td>
                          (<abbr title="Store" class="assembly-instruction">STO</abbr>
                        </td>
                        <td>
                          (<var>$ALIST</var> <var>i</var>)).
                        </td>
                      </tr>
                    </tbody>
                  </table>
                </div>
              </li>
              <li>
                <p>
Otherwise, the output is
                </p>
                <div>
                  <table class="assembly">
                    <tbody>
                      <tr>
                        <td>
                          (<abbr title="Load multiplier/quotient register" class="assembly-instruction">LDQ</abbr>
                        </td>
                        <td>
                          &langle;location of <var>a</var>&rangle;)
                        </td>
                      </tr>
                      <tr>
                        <td>
                          (<abbr title="Store from multiplier/quotient register" class="assembly-instruction">STQ</abbr>
                        </td>
                        <td>
                          (<var>$ALIST</var> <var>i</var>)).
                        </td>
                      </tr>
                    </tbody>
                  </table>
                </div>
              </li>
            </ol>
            <p>
Because <abbr title="Multiplier/quotient register" class="register">MQ</abbr> is used in the third case, the second
argument must be reloaded afterwards. If the second argument is in <abbr title="Accumulator register" class="register">AC</abbr>
because of <a href="listing.html#definition-comlis" class="internal-link"><span class="function">comlis</span></a>,
an <abbr title="Exchange multipler/quotient and accumulator registers" class="assembly-instruction">XCA</abbr> instruction is
generated. For example,
            </p>
            <div class="listing">
              <table>
                <tr>
                  <td>
                    (<span class="function">f</span> <span class="constant">nil</span> (<span class="function">g</span> <span class="constant">2</span>))
                  </td>
                </tr>
              </table>
            </div>
            <p>
results in
            </p>
            <div>
              <table class="assembly">
                <tbody>
                  <tr>
                    <td>(<abbr title="Clear and add" class="assembly-instruction">CLA</abbr></td>
                    <td>(<span class="operator">quote</span> <span class="constant">2</span>))</td>
                    <td></td>
                    <td></td>
                    <td class="assembly-comment">; set up argument of <span class="function">g</span> </td>
                  </tr>
                  <tr>
                    <td>(<abbr title="Store location and trap" class="assembly-instruction">STR</abbr></td>
                    <td>(<span class="operator">E</span> <span class="function">g</span>)</td>
                    <td><span class="constant">7</span></td>
                    <td><span class="constant">1)</span></td>
                    <td class="assembly-comment">; call <span class="function">g</span></td>
                  </tr>
                  <tr>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td class="assembly-comment">; the result of <span clas="function">g</span> is now in the accumulator</td>
                  </tr>
                  <tr>
                    <td>(<abbr title="Exchange multipler/quotient and accumulator registers" class="assembly-instruction">XCA</abbr>)</td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td class="assembly-comment">; but it's the second argument, so move it to <abbr title="Multiplier/quotient register" class="register">MQ</abbr></td>
                  </tr>
                  <tr>
                    <td>(<abbr title="Clear and add" class="assembly-instruction">CLA</abbr></td>
                    <td>(<span class="operator">quote</span> <span class="constant">nil</span>))</td>
                    <td></td>
                    <td></td>
                    <td class="assembly-comment">; put first argument of <span class="function">f</span> in <abbr title="Accumulator register" class="register">AC</abbr></td>
                  </tr>
                  <tr>
                    <td>(<abbr title="Store location and trap" class="assembly-instruction">STR</abbr></td>
                    <td>(<span class="operator">E</span> <span class="function">f</span>)</td>
                    <td><span class="constant">7</span></td>
                    <td><span class="constant">1)</span></td>
                    <td class="assembly-comment">; call <span class="function">f</span></td>
                  </tr>
                </tbody>
              </table>
            </div>
            <p>
In the common case where the second argument isn't already in the accumulator, the instruction generated is
            </p>
            <div>
              <table class="assembly">
                <tbody>
                  <tr>
                    <td>(<abbr title="Load multipler/quotient register" class="assembly-instruction">LDQ</abbr></td>
                    <td>&langle;result of calling <a href="listing.html#definition-locate" class="internal-link"><span class="function">locate</span></a> on the second argument&rangle;).</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <p>
There seems to be an unreachable code path in <a href="listing.html#definition-call" class="internal-link"><span class="function">call</span></a>.
It checks whether the first two arguments are the same, and if that value is in the accumulator it generates instructions to
to store it in <code><var>$ALIST</var>&nbsp;+&nbsp;2</code> and to copy it to <abbr title="Multiplier/quotient register" class="register">MQ</abbr>.
However, <a href="listing.html#definition-comlis" class="internal-link"><span class="function">comlis</span></a> always generates a unique symbol for
each subexpression and never lets <var>ac</var> contain a name that wasn't created by <span class="function">gensym</span>. In other words, after
calling <a href="listing.html#definition-comlis" class="internal-link"><span class="function">comlis</span></a>, <var>ac</var> will be
a newly-interned symbol. Perhaps this is a remnant of an earlier version.
            </p>
            <p>
The function <span class="function">list</span>, in compiled code, uses an odd calling convention (like
<a href="#move-routine" class="internal-link"><span class="function">*MOVE</span></a>), where arguments are passed in instructions following
a <abbr title="Transfer and set index" class="assembly-instruction">TSX</abbr>. More specifically, the code
            </p>
            <div class="listing">
              <table>
                <tbody>
                  <tr>
                    <td>(<span class="function">list</span> <var>a</var><sub>1</sub> &hellip; <var>a</var><sub><var>n</var></sub>)</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <p>
produces
            </p>
            <div>
              <table class="assembly">
                <tbody>
                  <tr>
                    <td>(<abbr title="Transfer and set index" class="assembly-instruction">TSX</abbr></td>
                    <td><span class="function">*LIST</span></td>
                    <td>4)</td>
                  </tr>
                  <tr>
                    <td>
                      (16777216 &times; <var>n</var>&emsp;
                    </td>
                    <td><var>a</var><sub>1</sub>)</td>
                  </tr>
                  <tr>
                    <td>(0</td>
                    <td><var>a</var><sub>2</sub>)
                    </td>
                  </tr>
                  <tr>
                    <td class="random-centered-table-row">
                      &vellip;
                    </td>
                  </tr>
                  <tr>
                    <td>(0</td>
                    <td><var>a</var><sub><var>n</var></sub></td>
                  </tr>
                </tbody>
              </table>
            </div>
            <p>
Note that 16777216 is 100000000 in octal. If the <span class="function">list</span> call has no arguments then the compiler
generates an instruction to load the constant <span class="constant">nil</span>.
            </p>
            <p>
The other functions with odd calling are <span class="function">specbind</span> and <span class="function">specrstr</span>, which
<a href="#specbind-specrstr" class="internal-link">were inserted into the input in pass one</a>. They both use the same convention:
            </p>
            <div class="listing">
              <table>
                <tbody>
                  <tr>
                    <td>
                      (<span class="function">specbind</span>/<span class="function">specrstr</span>
                      (<span class="operator">quote</span> (<var>s</var><sub>1</sub> &hellip; <var>s</var><sub><var>n</var></sub>)))
                    </td>
                  </tr>
                </tbody>
              </table>
            </div>
            <p>
compiles to
            </p>
            <div>
              <table class="assembly">
                <tbody>
                  <tr>
                    <td>(<abbr title="Transfer and set index" class="assembly-instruction">TSX</abbr></td>
                    <td><span class="function">specbind</span>/<span class="function">specrstr</span></td>
                    <td>4)</td>
                  </tr>
                  <tr>
                    <td>
                      (0
                    </td>
                    <td>(&langle;offset of <var>s</var><sub>1</sub> on the <abbr title="Push-down list">PDL</abbr>&rangle; <var>*N</var>)</td>
                    <td>1</td>
                    <td>(<span class="operator">SPECIAL</span> <var>s</var><sub>1</sub>))</td>
                  </tr>
                  <tr>
                    <td>(0
                    </td>
                    <td>(&langle;offset of <var>s</var><sub>2</sub> on the <abbr title="Push-down list">PDL</abbr>&rangle; <var>*N</var>)</td>
                    <td>1</td>
                    <td>(<span class="operator">SPECIAL</span> <var>s</var><sub>2</sub>))</td>
                  </tr>
                  <tr>
                    <td class="random-centered-table-row" colspan="5">
                      &vellip;
                    </td>
                  </tr>
                  <tr>
                    <td>(<abbr title="Store location and trap" class="assembly-instruction">STR</abbr></td>
                    <td>(&langle;offset of <var>s</var><sub><var>n</var></sub> on the <abbr title="Push-down list">PDL</abbr>&rangle; <var>*N</var>)</td>
                    <td>1</td>
                    <td>(<span class="operator">SPECIAL</span> <var>s</var><sub><var>n</var></sub>))</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <p>
In LISP&nbsp;1.5, the <span class="function">car</span> of an expression can be non-atomic, as in
            </p>
            <div class="listing">
              <table>
                <tbody>
                  <tr>
                    <td>(<table>
                        <tbody>
                          <tr>
                            <td>(<span class="operator">&lambda;</span> (<var>x</var>) &langle;expression<sub>1</sub>&rangle;)</td>
                          </tr>
                          <tr><td>&langle;expression<sub>2</sub>&rangle;).</td></tr>
                        </tbody>
                      </table>
                    </td>
                  </tr>
                </tbody>
              </table>
            </div>
            <p>
The interpreter will evaluate &langle;expression<sub>1</sub>&rangle; in an environment where <var>x</var> is bound to
the result of evaluating &langle;expression<sub>2</sub>&rangle;. The compiler basically does the exact same thing,
using a helper function named 
<a href="listing.html#definition-comply" class="internal-link"><span class="function">comply</span></a> (perhaps
a portmanteau of &ldquo;compile&rdquo; and &ldquo;apply&rdquo;). Each argument is compiled; its result is put on the
<var>stomap</var> under the name of the corresponding parameter. Then the local function's body is compiled with the
new <var>stomap</var> containing entries for the parameters.
            </p>
            <p>
            </p>
          </section>
          <section class="normal" id="compiling-prog-forms">
            <h4><a href="#compiling-prog-forms" class="section-title">Compiling prog forms</a></h4>
            <p>
The &ldquo;program feature&rdquo; is the least Lispy part of Lisp, so it makes sense that its compilation
is straightforward; the function responsible is
<a href="listing.html#definition-comprog" class="internal-link"><span class="function">comprog</span></a>.
First, <a href="listing.html#definition-comprog" class="internal-link"><span class="function">comprog</span></a>
goes through the form, making a list that pairs tags with generated symbols, to avoid naming conflicts with
any inner <span class="operator">prog</span>s. This list is stored in the special variable <var>golist</var>,
which is also used by
<a href="listing.html#definition-comcond" class="internal-link"><span class="function">comcond</span></a>,
a function we will discuss momentarily. The symbols in the <var>golist</var> turn into labels in the
<abbr title="Lisp Assembly Program">LAP</abbr> output.
            </p>
            <p>
Code is generated to set the <span class="operator">prog</span> variables to 0 (<span class="constant">nil</span>),
unless the variable was added in pass one to help save/restore the values of special variables.
            </p>
            <p>
The forms in the body of the <span class="operator">prog</span> are then
<a href="listing.html#definition-comval" class="internal-link"><span class="function">comval</span></a>'d, except that
<span class="operator">go</span> forms are handled. Namely, the statement
            </p>
            <div class="listing">
              <table>
                <tbody>
                  <tr>
                    <td>
                      (<span class="operator">go</span> <span class="prog-tag">x</span>)
                    </td>
                  </tr>
                </tbody>
              </table>
            </div>
            <p>
becomes a simple
            </p>
            <div>
              <table class="assembly">
                <tbody>
                  <tr>
                    <td>(<abbr title="Transfer" class="assembly-instruction">TRA</abbr>
                      &langle;generated label corresponding to <span class="prog-tag">x</span>&rangle;).
                    </td>
                  </tr>
                </tbody>
              </table>
            </div>
            <p>
Compiling <span class="operator">return</span> expressions is not done by
<a href="listing.html#definition-comprog" class="internal-link"><span class="function">comprog</span></a>,
but by
<a href="listing.html#definition-call" class="internal-link"><span class="function">call</span></a>.
A <span class="operator">return</span> form has two possible translations, depending on whether the
<span class="operator">prog</span> in which it occurs is the main body of a function or a subexpression.
In the former case, the output is
            </p>
            <div>
              <table class="assembly">
                <tbody>
                  <tr>
                    <td>&langle;code to load the return value into <abbr title="Accumulator register" class="register">AC</abbr>&rangle;
                    </td>
                  </tr>
                  <tr>
                    <td>(<abbr title="Transfer with index incremented" class="assembly-instruction">TXI</abbr>
                      <a href="#return" class="internal-link"><span class="function">*RETURN</span></a> <span class="constant">1</span> <var>*MN</var>).
                    </td>
                  </tr>
                </tbody>
              </table>
            </div>
            <p>
In the latter case, the output is
            </p>
            <div>
              <table class="assembly">
                <tbody>
                  <tr>
                    <td>&langle;code to load the return value into <abbr title="Accumulator register" class="register">AC</abbr>&rangle;
                    </td>
                  </tr>
                  <tr>
                    <td>(<abbr title="Transfer" class="assembly-instruction">TRA</abbr>
                      &langle;a label generated to mark the end of the <span class="operator">prog</span>&rangle;).
                    </td>
                  </tr>
                </tbody>
              </table>
            </div>
            <p>
The last thing <a href="listing.html#definition-comprog" class="internal-link"><span class="function">comprog</span></a>
does is <a href="listing.html#definition-attach" class="internal-link"><span class="function">attach</span></a>
that generated label to the assembly output, if it exists.
            </p>
          </section>
          <section class="normal" id="compiling-conditionals">
            <h4><a href="#compiling-conditionals" class="section-title">Compiling conditionals</a></h4>
            <p>
The routines responsible for compiling conditionals and Boolean expressions are
<a href="listing.html#definition-comcond" class="internal-link"><span class="function">comcond</span></a>,
<a href="listing.html#definition-combool" class="internal-link"><span class="function">combool</span></a>, and
<a href="listing.html#definition-compact" class="internal-link"><span class="function">compact</span></a>,
which have (more or less) the following purposes.
            </p>
            <ul>
              <li>
                <p>
<a href="listing.html#definition-combool" class="internal-link"><span class="function">combool</span></a> compiles
an <span class="operator">and</span> or <span class="operator">or</span> form.
                </p>
              </li>
              <li>
                <p>
<a href="listing.html#definition-compact" class="internal-link"><span class="function">compact</span></a> compiles
a form used as a test in a conditional.
                </p>
              </li>
              <li>
                <p>
<a href="listing.html#definition-comcond" class="internal-link"><span class="function">comcond</span></a> compiles
a <span class="operator">cond</span> form.
                </p>
              </li>
            </ul>
            <p>
Understanding these routines is complicated somewhat by the fact that
<a href="listing.html#definition-combool" class="internal-link"><span class="function">combool</span></a> and
<a href="listing.html#definition-compact" class="internal-link"><span class="function">compact</span></a> call
each other&mdash;but this is reasonable because
<span class="operator">and</span> and <span class="operator">or</span> can be written in terms of
<span class="operator">cond</span>.
            </p>
            <p>
The code generated for the expression
            </p>
            <div class="listing">
              <table>
                <tbody>
                  <tr>
                    <td>
                      (<span class="operator">and</span> <var>e</var><sub>1</sub> <var>e</var><sub>2</sub> <var>e</var><sub>3</sub>)    
                    </td>
                  </tr>
                </tbody>
              </table>
            </div>
            <p>
is
            </p>
            <div>
              <table class="assembly">
                <tbody>
                  <tr>
                    <td></td>
                    <td class="random-centered-table-row" colspan="4">&langle;code to evaluate <var>e</var><sub>1</sub>&rangle;</td>
                  </tr>
                  <tr>
                    <td></td>
                    <td>(<abbr title="Transfer on zero" class="assembly-instruction">TZE</abbr></td>
                    <td><span class="prog-tag">label</span>)</td>
                  </tr>
                  <tr>
                    <td></td>
                    <td class="random-centered-table-row" colspan="4">&langle;code to evaluate <var>e</var><sub>2</sub>&rangle;</td>
                  </tr>
                  <tr>
                    <td></td>
                    <td>(<abbr title="Transfer on zero" class="assembly-instruction">TZE</abbr></td>
                    <td><span class="prog-tag">label</span>)</td>
                  </tr>
                  <tr>
                    <td></td>
                    <td class="random-centered-table-row" colspan="4">&langle;code to evaluate <var>e</var><sub>3</sub>&rangle;</td>
                  </tr>
                  <tr>
                    <td></td>
                    <td>(<abbr title="Transfer on zero" class="assembly-instruction">TZE</abbr></td>
                    <td><span class="prog-tag">label</span>)</td>
                  </tr>
                  <tr>
                    <td></td>
                    <td>(<abbr title="Clear and add" class="assembly-instruction">CLA</abbr></td>
                    <td>(<span class="operator">quote</span> <span class="constant">*t*</span>))</td>
                  </tr>
                  <tr>
                    <td></td>
                    <td>(<abbr title="Transfer" class="assembly-instruction">TRA</abbr></td>
                    <td>(* <span class="constant">2</span>))</td>
                  </tr>
                  <tr>
                    <td class="label"><span class="prog-tag">label</span></td>
                    <td>(<abbr title="Clear and add" class="assembly-instruction">CLA</abbr></td>
                    <td>(<span class="operator">quote</span> <span class="constant">nil</span>)).</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <p>
The code for
            </p>
            <div class="listing">
              <table>
                <tbody>
                  <tr>
                    <td>
                      (<span class="operator">or</span> <var>e</var><sub>1</sub> <var>e</var><sub>2</sub> <var>e</var><sub>3</sub>)    
                    </td>
                  </tr>
                </tbody>
              </table>
            </div>
            <p>
is quite similar.
            </p>
            <div>
              <table class="assembly">
                <tbody>
                  <tr>
                    <td></td>
                    <td class="random-centered-table-row" colspan="4">&langle;code to evaluate <var>e</var><sub>1</sub>&rangle;</td>
                  </tr>
                  <tr>
                    <td></td>
                    <td>(<abbr title="Transfer on no zero" class="assembly-instruction">TNZ</abbr></td>
                    <td><span class="prog-tag">label</span>)</td>
                  </tr>
                  <tr>
                    <td></td>
                    <td class="random-centered-table-row" colspan="4">&langle;code to evaluate <var>e</var><sub>2</sub>&rangle;</td>
                  </tr>
                  <tr>
                    <td></td>
                    <td>(<abbr title="Transfer on no zero" class="assembly-instruction">TNZ</abbr></td>
                    <td><span class="prog-tag">label</span>)</td>
                  </tr>
                  <tr>
                    <td></td>
                    <td class="random-centered-table-row" colspan="4">&langle;code to evaluate <var>e</var><sub>3</sub>&rangle;</td>
                  </tr>
                  <tr>
                    <td></td>
                    <td>(<abbr title="Transfer on no zero" class="assembly-instruction">TNZ</abbr></td>
                    <td><span class="prog-tag">label</span>)</td>
                  </tr>
                  <tr>
                    <td></td>
                    <td>(<abbr title="Clear and add" class="assembly-instruction">CLA</abbr></td>
                    <td>(<span class="operator">quote</span> <span class="constant">nil</span>))</td>
                  </tr>
                  <tr>
                    <td></td>
                    <td>(<abbr title="Transfer" class="assembly-instruction">TRA</abbr></td>
                    <td>(* <span class="constant">2</span>))</td>
                  </tr>
                  <tr>
                    <td class="label"><span class="prog-tag">label</span></td>
                    <td>(<abbr title="Clear and add" class="assembly-instruction">CLA</abbr></td>
                    <td>(<span class="operator">quote</span> <span class="constant">*t*</span>))</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <p>
The label will have been generated by <span class="function">gensym</span>. In real code, some other instructions
will follow the translation, so the <abbr title="Transfer" class="assembly-instruction">TRA</abbr> is meaningful.
            </p>
            <p>
In the LISP&nbsp;1.5 system, the atom <span class="constant">nil</span> happens to be stored at location 0. Thus
the code can compare the <abbr title="Accumulator register" class="register">AC</abbr> with 0 to test for truth.
            </p>
            <p>
The translations of <span class="operator">and</span> and <span class="operator">or</span> are different when they
occur in the test (or antecedent) part of a <span class="operator">cond</span> clause. In a
<span class="operator">cond</span>, the <abbr title="Transfer on no zero" class="assembly-instruction">TNZ</abbr>
and <abbr title="Transfer on zero" class="assembly-instruction">TZE</abbr> instructions jump to a label
generated by <a href="listing.html#definition-comcond" class="internal-link"><span class="function">comcond</span></a>,
instead of the one generated in
<a href="listing.html#definition-combool" class="internal-link"><span class="function">combool</span></a> (which ends
up in the assembly output but is never transfered to). Furthermore, the code doesn't load <span class="constant">*t*</span>
or <span class="constant">nil</span>.
            </p>
            <p>
A <span class="operator">cond</span> form
            </p>
            <div class="listing">
              <table>
                <tbody>
                  <tr>
                    <td>
                      (<span class="operator">cond</span>
                      <table>
                        <tbody>
                          <tr>
                            <td>(<var>test</var><sub>1</sub></td>
                            <td><var>consequent</var><sub>1</sub>)
                            </td>
                          </tr>
                          <tr>
                            <td>(<var>test</var><sub>2</sub></td>
                            <td><var>consequent</var><sub>2</sub>)
                            </td>
                          </tr>
                          <tr>
                            <td>((<span class=function>not</span> <var>test</var><sub>3</sub>)&nbsp;</td>
                            <td><var>consequent</var><sub>3</sub>))
                            </td>
                          </tr>
                          <tr>
                            <td>(<span class="constant">t</span></td>
                            <td><var>consequent</var><sub>4</sub>))
                            </td>
                          </tr>
                        </tbody>
                      </table>
                    </td>
                  </tr>
                </tbody>
              </table>
            </div>
            <p>
results in output like
            </p>
            <div>
              <table class="assembly">
                <tbody>
                  <tr>
                    <td></td>
                    <td colspan="4">&langle;code to evaluate <var>test</var><sub>1</sub>&rangle;</td>
                  </tr>
                  <tr>
                    <td></td>
                    <td>(<abbr title="Transfer on zero" class="assembly-instruction">TZE</abbr></td>
                    <td><span class="prog-tag">false-label</span><sub>1</sub>)</td>
                  </tr>
                  <tr>
                    <td></td>
                    <td colspan="4">&langle;code to evaluate <var>consequent</var><sub>1</sub>&rangle;</td>
                  </tr>
                  <tr>
                    <td></td>
                    <td>(<abbr title="Transfer on zero" class="assembly-instruction">TRA</abbr></td>
                    <td><span class="prog-tag">end-conditional</span>)</td>
                  </tr>
                  <tr>
                    <td class="label"><span class="prog-tag">false-label</span><sub>1</sub></td>
                    <td colspan="4">&langle;code to evaluate <var>test</var><sub>2</sub>&rangle;</td>
                  </tr>
                  <tr>
                    <td></td>
                    <td>(<abbr title="Transfer on zero" class="assembly-instruction">TZE</abbr></td>
                    <td><span class="prog-tag">false-label</span><sub>2</sub>)</td>
                  </tr>
                  <tr>
                    <td></td>
                    <td colspan="4">&langle;code to evaluate <var>consequent</var><sub>2</sub>&rangle;</td>
                  </tr>
                  <tr>
                    <td></td>
                    <td>(<abbr title="Transfer on zero" class="assembly-instruction">TRA</abbr></td>
                    <td><span class="prog-tag">end-conditional</span>)</td>
                  </tr>
                  <tr>
                    <td class="label"><span class="prog-tag">false-label</span><sub>2</sub></td>
                    <td colspan="4">&langle;code to evaluate <var>test</var><sub>3</sub>&rangle;</td>
                  </tr>
                  <tr>
                    <td></td>
                    <td>(<abbr title="Transfer on no zero" class="assembly-instruction">TNZ</abbr></td>
                    <td><span class="prog-tag">false-label</span><sub>3</sub>)</td>
                  </tr>
                  <tr>
                    <td></td>
                    <td colspan="4">&langle;code to evaluate <var>consequent</var><sub>2</sub>&rangle;</td>
                  </tr>
                  <tr>
                    <td></td>
                    <td>(<abbr title="Transfer on zero" class="assembly-instruction">TRA</abbr></td>
                    <td><span class="prog-tag">end-conditional</span>)</td>
                  </tr>
                  <tr>
                    <td class="label"><span class="prog-tag">false-label</span><sub>2</sub></td>
                    <td colspan="4">&langle;code to evaluate <var>consequent</var><sub>4</sub>&rangle;</td>
                  </tr>
                  <tr>
                    <td class="label"><span class="prog-tag">end-conditional</span></td>
                    <td colspan="4">&hellip;&thinsp;.</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <p>
As you can see, the code for the final clause does not &ldquo;test&rdquo; <span class="constant">t</span>; instead
it simply goes on to <var>consequent</var><sub>4</sub>. A call to <span class="function">not</span> is also avoided
by using <abbr title="Transfer on no zero" class="assembly-instruction">TNZ</abbr> instead of
<abbr title="Transfer on zero" class="assembly-instruction">TZE</abbr>.
Another clever optimization, not shown here, involves
<span class="operator">go</span>. When a clause's consequent is a <span class="operator">go</span> expression,
the condition is inverted (by wrapping the test in <span class="function">null</span>) and one of
<a href="listing.html#definition-compact" class="internal-link"><span class="function">compact</span></a>'s arguments
is abused so that a successful test transfers to the <span class="operator">go</span> statement's target.
            </p>
            <p>
There remains only one loose end:
A special case in <a href="listing.html#definition-compact" class="internal-link"><span class="function">compact</span></a>,
using a subroutine named <a href="listing.html#definition-ceq" class="internal-link"><span class="function">ceq</span></a>,
compiles <span class="function">eq</span> expressions into <abbr title="Subtract" class="assembly-instruction">SUB</abbr>
instructions.
            </p>
          </section>
        </section>
      </section>
    </article>
  </body>
</html>
